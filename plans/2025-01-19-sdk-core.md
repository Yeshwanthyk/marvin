# SDK Core Improvements Implementation Plan

## Plan Metadata
- Created: 2025-01-19
- Status: complete
- Owner: yesh
- Related: `plans/2025-01-19-sdk-extended.md` (follow-up plan)
- Assumptions:
  - SDK consumers use both Promise and Effect APIs
  - Backward compatibility with existing `runAgent`/`createAgentSession` signatures
  - Internal runtime capabilities already exist, need exposure

## Progress Tracking
- [x] Phase 1: Abort & Cancellation
- [x] Phase 2: Error Types Overhaul
- [x] Phase 3: Model Parameters & Result Enrichment
- [x] Phase 4: Session Export/Import

## Overview
Expose core SDK capabilities: abort/cancellation, granular error types (self-documenting via Effect), model parameters, and session serialization.

## Current State

### Key Discoveries

**SDK exports** (`packages/sdk/src/index.ts`):
```typescript
export { runAgent, runAgentEffect } from "./run-agent.js"
export { createAgentSession, createAgentSessionEffect } from "./session.js"
export { runAgentStream } from "./stream.js"
```

**Error types are coarse** (`packages/sdk/src/errors.ts:3-9`):
```typescript
export type SdkErrorTag = "ConfigError" | "RuntimeError" | "TransportError" | "HookError"
export type SdkError = { _tag: SdkErrorTag; message: string; cause?: string }
```

**Abort exists in Agent** (`packages/agent/src/agent.ts:196-198`):
```typescript
abort() {
  this.abortController?.abort();
}
```

**AppMessage has stopReason** (`packages/agent/src/types.ts`):
```typescript
stopReason?: "complete" | "maxTokens" | "tool" | "error" | "aborted"
```

## Desired End State

### SDK Options (after this plan)
```typescript
interface RunAgentOptions {
  prompt: string
  provider?: string
  model?: string
  thinking?: ThinkingLevel
  systemPrompt?: string
  attachments?: Attachment[]
  mode?: PromptDeliveryMode
  // NEW in this plan
  signal?: AbortSignal
  maxTokens?: number
  temperature?: number
}
```

### SDK Result
```typescript
interface SdkResult {
  text: string
  messages: AppMessage[]
  toolCalls: ToolCall[]
  usage?: Usage
  provider: string
  model: string
  sessionId: string | null
  // NEW
  stopReason: "complete" | "maxTokens" | "aborted" | "error"
  durationMs: number
}
```

### SDK Session
```typescript
interface SdkSession {
  chat(text: string, options?: ChatOptions): Promise<SdkResult>
  snapshot(): Promise<SdkSessionSnapshot>
  abort(): void  // NEW
  export(): Promise<SessionState>  // NEW
  close(): Promise<void>
}

createAgentSession({ restore?: SessionState })  // NEW
```

### Error Types
```typescript
type SdkError =
  | { _tag: "ConfigError"; code: "CONFIG_MISSING" | "CONFIG_INVALID"; message: string; retryable: false }
  | { _tag: "ProviderError"; code: "AUTH" | "RATE_LIMITED" | "OVERLOADED" | "MODEL_NOT_FOUND"; message: string; retryable: boolean }
  | { _tag: "RequestError"; code: "TIMEOUT" | "ABORTED" | "CONTEXT_LENGTH"; message: string; retryable: boolean }
  | { _tag: "HookError"; message: string; retryable: false }
```

### Verification
```bash
bun run typecheck
bun test packages/sdk/tests
```

Manual:
- [ ] `runAgent({ signal: AbortSignal.timeout(5000) })` aborts after 5s
- [ ] `session.abort()` stops mid-stream
- [ ] Error types show in IDE hover on `runAgentEffect`
- [ ] `session.export()` returns serializable state

## Out of Scope
- Retry/timeout configuration (see sdk-extended plan)
- Effect Stream exposure (see sdk-extended plan)
- Tool filtering (see sdk-extended plan)
- Examples/README (see sdk-extended plan)
- Custom tools/hooks registration via SDK

## Breaking Changes

**SdkError shape change** - from:
```typescript
{ _tag: SdkErrorTag; message: string; cause?: string }
```
to discriminated union with `code` and `retryable`. Consumers using `error._tag` continue to work. New fields are additive.

**SdkResult additions** - `stopReason` and `durationMs` are new required fields. Existing code unaffected.

## Dependency and Configuration Changes
None required.

## Error Handling Strategy

All errors flow through `toSdkError()` which classifies based on:
1. Error message patterns (rate limit, auth, timeout)
2. Error names (AbortError)
3. HTTP status codes if available

Pattern matching uses existing `execution-plan.ts` classifications:
- `NETWORK_ERROR_PATTERNS` → `RequestError` + retryable
- `RATE_LIMIT_PATTERNS` → `ProviderError.RATE_LIMITED` + retryable
- `AUTH_PATTERNS` → `ProviderError.AUTH` + not retryable
- `PROVIDER_OUTAGE_PATTERNS` → `ProviderError.OVERLOADED` + retryable

## Implementation Approach

Phased approach exposing internal capabilities without changing runtime behavior:
1. Thread AbortSignal through SDK → runtime → agent
2. Refactor error types using existing classification logic
3. Add model params and result enrichment
4. Session serialization

## Phase Dependencies and Parallelization
- Phase 1 (Abort) - standalone
- Phase 2 (Errors) - standalone, can parallel with Phase 1
- Phase 3 (Model params) - standalone, can parallel with Phase 1-2
- Phase 4 (Session export) - depends on Phase 1 (needs abort for clean export)

Suggested parallel execution:
- Agent 1: Phase 1 (Abort)
- Agent 2: Phase 2 (Errors)
- Agent 3: Phase 3 (Model params)
- Then: Phase 4 (Session export)

---

## Phase 1: Abort & Cancellation

### Overview
Expose AbortSignal through SDK options, wire to agent.abort(), add session.abort() method.

### Prerequisites
- [ ] None

### Change Checklist
- [ ] Add `signal?: AbortSignal` to SDK option types
- [ ] Wire signal to runtime
- [ ] Create abort subscription in SDK runtime
- [ ] Add `abort()` to SdkSession interface
- [ ] Add tests

### Changes

#### 1. Add signal to SDK types
**File**: `packages/sdk/src/types.ts`
**Location**: lines 41-47 (RunAgentOptions)

**Before**:
```typescript
export interface RunAgentOptions extends SdkBaseOptions {
  prompt: string
  mode?: PromptDeliveryMode
  attachments?: Attachment[]
}
```

**After**:
```typescript
export interface RunAgentOptions extends SdkBaseOptions {
  prompt: string
  mode?: PromptDeliveryMode
  attachments?: Attachment[]
  signal?: AbortSignal
}
```

**Why**: Allow consumers to pass AbortSignal for cancellation.

#### 2. Add signal to SdkRuntimeOptions
**File**: `packages/sdk/src/runtime.ts`
**Location**: lines 18-24 (SdkRuntimeOptions)

**Before**:
```typescript
export interface SdkRuntimeOptions extends LoadConfigOptions {
  instrumentation?: (event: InstrumentationEvent) => void
  instrumentationSink?: (event: InstrumentationEvent) => void
  hookMessageSink?: (message: HookMessage) => void
  transportFactory?: TransportFactory
}
```

**After**:
```typescript
export interface SdkRuntimeOptions extends LoadConfigOptions {
  instrumentation?: (event: InstrumentationEvent) => void
  instrumentationSink?: (event: InstrumentationEvent) => void
  hookMessageSink?: (message: HookMessage) => void
  transportFactory?: TransportFactory
  signal?: AbortSignal
}
```

#### 3. Wire signal to agent abort
**File**: `packages/sdk/src/runtime.ts`
**Location**: inside createSdkRuntimeImpl, after `const services: RuntimeServices = Context.get(context, RuntimeServicesTag)` (around line 158)

**Add**:
```typescript
// Wire external AbortSignal to agent.abort()
if (options.signal) {
  if (options.signal.aborted) {
    yield* Effect.fail(toSdkError(new DOMException("Aborted", "AbortError"), "RequestError"))
  }
  const onAbort = () => services.agent.abort()
  options.signal.addEventListener("abort", onAbort, { once: true })
  yield* Effect.addFinalizer(() => Effect.sync(() => {
    options.signal?.removeEventListener("abort", onAbort)
  }))
}
```

**Why**: External signal triggers internal abort mechanism. Check if already aborted at start.

#### 4. Add abort to SdkSession interface
**File**: `packages/sdk/src/types.ts`
**Location**: lines 55-65 (SdkSession interface)

**Before**:
```typescript
export interface SdkSession<
  Chat = SdkEffect<SdkResult>,
  Snapshot = SdkEffect<SdkSessionSnapshot>,
  Drain = SdkEffect<string | null>,
  Close = Effect.Effect<void>
> {
  chat: (text: string, options?: { mode?: PromptDeliveryMode; attachments?: Attachment[] }) => Chat
  snapshot: () => Snapshot
  drainQueue: () => Drain
  close: () => Close
}
```

**After**:
```typescript
export interface SdkSession<
  Chat = SdkEffect<SdkResult>,
  Snapshot = SdkEffect<SdkSessionSnapshot>,
  Drain = SdkEffect<string | null>,
  Close = Effect.Effect<void>,
  Abort = Effect.Effect<void>
> {
  chat: (text: string, options?: { mode?: PromptDeliveryMode; attachments?: Attachment[]; signal?: AbortSignal }) => Chat
  snapshot: () => Snapshot
  drainQueue: () => Drain
  abort: () => Abort
  close: () => Close
}
```

#### 5. Update SdkSessionPromise type
**File**: `packages/sdk/src/types.ts`
**Location**: lines 69-74

**Before**:
```typescript
export type SdkSessionPromise = SdkSession<
  Promise<SdkResult>,
  Promise<SdkSessionSnapshot>,
  Promise<string | null>,
  Promise<void>
>
```

**After**:
```typescript
export type SdkSessionPromise = SdkSession<
  Promise<SdkResult>,
  Promise<SdkSessionSnapshot>,
  Promise<string | null>,
  Promise<void>,
  void
>
```

#### 6. Implement abort in session.ts
**File**: `packages/sdk/src/session.ts`
**Location**: inside createAgentSessionEffect, before the return statement

**Add** (after `const drainQueue = ...`):
```typescript
const abort = () => Effect.sync(() => runtime.services.agent.abort())
```

**Update return**:
```typescript
return { chat, snapshot, drainQueue, abort, close } satisfies SdkSessionEffect
```

#### 7. Update Promise wrapper
**File**: `packages/sdk/src/session.ts`
**Location**: inside createAgentSession return object (around line 55)

**Before**:
```typescript
return {
  chat: (text, promptOptions) => Effect.runPromise(session.chat(text, promptOptions)),
  snapshot: () => Effect.runPromise(session.snapshot()),
  drainQueue: () => Effect.runPromise(session.drainQueue()),
  close: () => Effect.runPromise(session.close()),
}
```

**After**:
```typescript
return {
  chat: (text, promptOptions) => Effect.runPromise(session.chat(text, promptOptions)),
  snapshot: () => Effect.runPromise(session.snapshot()),
  drainQueue: () => Effect.runPromise(session.drainQueue()),
  abort: () => { Effect.runSync(session.abort()) },
  close: () => Effect.runPromise(session.close()),
}
```

#### 8. Add import for toSdkError
**File**: `packages/sdk/src/runtime.ts`
**Location**: imports at top

**Add to existing import**:
```typescript
import { toSdkError } from "./errors.js"
```

### Edge Cases to Handle
- [ ] Signal already aborted before call: Check `signal.aborted` at start, fail immediately
- [ ] Abort during tool execution: Agent handles this internally
- [ ] Multiple abort calls: Idempotent, no-op if already aborted

### Success Criteria

**Automated**:
```bash
bun run typecheck
bun test packages/sdk/tests
```

**Manual**:
- [ ] `runAgent({ prompt: "count to 100", signal: AbortSignal.timeout(100) })` returns error with code "ABORTED"
- [ ] `session.abort()` stops mid-stream response

### Rollback
```bash
git restore packages/sdk/src/types.ts packages/sdk/src/runtime.ts packages/sdk/src/session.ts
```

### Notes
[Implementation notes go here]

---

## Phase 2: Error Types Overhaul

### Overview
Replace coarse SdkErrorTag with granular discriminated union. Leverage existing error classification from execution-plan.ts. Error types become self-documenting via Effect's type signature.

### Prerequisites
- [ ] None (can parallel with Phase 1)

### Change Checklist
- [ ] Define new error type hierarchy
- [ ] Create error factory functions
- [ ] Update toSdkError to classify errors properly
- [ ] Update all error sites to use new types
- [ ] Update exports
- [ ] Add tests

### Changes

#### 1. Define new error types
**File**: `packages/sdk/src/errors.ts`
**Location**: replace entire file

**Before**:
```typescript
import { isRecord, toErrorMessage } from "./internal.js"

export type SdkErrorTag = "ConfigError" | "RuntimeError" | "TransportError" | "HookError"

export type SdkError = {
  _tag: SdkErrorTag
  message: string
  cause?: string
}

const isSdkErrorTag = (value: unknown): value is SdkErrorTag =>
  value === "ConfigError" ||
  value === "RuntimeError" ||
  value === "TransportError" ||
  value === "HookError"

export const isSdkError = (value: unknown): value is SdkError => {
  if (!isRecord(value)) return false
  const tag = value["_tag"]
  const message = value["message"]
  if (!isSdkErrorTag(tag) || typeof message !== "string") return false
  const cause = value["cause"]
  if (cause !== undefined && typeof cause !== "string") return false
  return true
}

export const toSdkError = (value: unknown, fallbackTag: SdkErrorTag = "RuntimeError"): SdkError => {
  if (isSdkError(value)) return value
  return { _tag: fallbackTag, message: toErrorMessage(value) }
}
```

**After**:
```typescript
import { isRecord, toErrorMessage } from "./internal.js"

// Error codes for each category
export type ConfigErrorCode = "CONFIG_MISSING" | "CONFIG_INVALID"
export type ProviderErrorCode = "AUTH" | "RATE_LIMITED" | "OVERLOADED" | "MODEL_NOT_FOUND"
export type RequestErrorCode = "TIMEOUT" | "ABORTED" | "CONTEXT_LENGTH" | "NETWORK"
export type HookErrorCode = "HOOK_FAILED"

// Discriminated union of all SDK errors
export type SdkError =
  | { readonly _tag: "ConfigError"; readonly code: ConfigErrorCode; readonly message: string; readonly retryable: false }
  | { readonly _tag: "ProviderError"; readonly code: ProviderErrorCode; readonly message: string; readonly retryable: boolean }
  | { readonly _tag: "RequestError"; readonly code: RequestErrorCode; readonly message: string; readonly retryable: boolean }
  | { readonly _tag: "HookError"; readonly code: HookErrorCode; readonly message: string; readonly retryable: false }

// Legacy tag type for backward compatibility
export type SdkErrorTag = SdkError["_tag"]

// Error constructors
export const ConfigError = (code: ConfigErrorCode, message: string): SdkError =>
  ({ _tag: "ConfigError", code, message, retryable: false })

export const ProviderError = (code: ProviderErrorCode, message: string): SdkError => ({
  _tag: "ProviderError",
  code,
  message,
  retryable: code === "RATE_LIMITED" || code === "OVERLOADED",
})

export const RequestError = (code: RequestErrorCode, message: string): SdkError => ({
  _tag: "RequestError",
  code,
  message,
  retryable: code === "NETWORK" || code === "TIMEOUT",
})

export const HookError = (message: string): SdkError =>
  ({ _tag: "HookError", code: "HOOK_FAILED", message, retryable: false })

// Pattern matching for error classification
const NETWORK_PATTERNS = [
  "ECONNRESET", "ECONNREFUSED", "EAI_AGAIN", "EPIPE", "socket hang up",
  "network error", "Failed to fetch", "fetch failed", "ETIMEDOUT",
  "ENOTFOUND", "TLS handshake timeout",
] as const

const RATE_LIMIT_PATTERNS = [
  "rate limit", "too many requests", "exceeded your current quota", "429",
] as const

const AUTH_PATTERNS = [
  "invalid api key", "unauthorized", "access denied", "permission", "401",
] as const

const OVERLOAD_PATTERNS = [
  "overloaded", "at capacity", "service unavailable", "bad gateway", "503", "502",
] as const

const CONTEXT_LENGTH_PATTERNS = [
  "context length", "too many tokens", "maximum context", "token limit",
] as const

const TIMEOUT_PATTERNS = [
  "timeout", "timed out", "deadline exceeded",
] as const

const matchesPattern = (message: string, patterns: readonly string[]): boolean => {
  const lower = message.toLowerCase()
  return patterns.some((p) => lower.includes(p.toLowerCase()))
}

const isAbortError = (error: unknown): boolean =>
  typeof error === "object" &&
  error !== null &&
  "name" in error &&
  (error as { name?: unknown }).name === "AbortError"

export const isSdkError = (value: unknown): value is SdkError => {
  if (!isRecord(value)) return false
  const tag = value["_tag"]
  return tag === "ConfigError" || tag === "ProviderError" || tag === "RequestError" || tag === "HookError"
}

export const toSdkError = (value: unknown, fallbackTag: SdkErrorTag = "RequestError"): SdkError => {
  if (isSdkError(value)) return value

  const message = toErrorMessage(value)

  // Check for abort
  if (isAbortError(value) || message.toLowerCase().includes("aborted")) {
    return RequestError("ABORTED", message)
  }

  // Check for timeout
  if (matchesPattern(message, TIMEOUT_PATTERNS)) {
    return RequestError("TIMEOUT", message)
  }

  // Classify by pattern
  if (matchesPattern(message, AUTH_PATTERNS)) {
    return ProviderError("AUTH", message)
  }
  if (matchesPattern(message, RATE_LIMIT_PATTERNS)) {
    return ProviderError("RATE_LIMITED", message)
  }
  if (matchesPattern(message, OVERLOAD_PATTERNS)) {
    return ProviderError("OVERLOADED", message)
  }
  if (matchesPattern(message, CONTEXT_LENGTH_PATTERNS)) {
    return RequestError("CONTEXT_LENGTH", message)
  }
  if (matchesPattern(message, NETWORK_PATTERNS)) {
    return RequestError("NETWORK", message)
  }

  // Fallback based on hint
  switch (fallbackTag) {
    case "ConfigError":
      return ConfigError("CONFIG_INVALID", message)
    case "HookError":
      return HookError(message)
    case "ProviderError":
      return ProviderError("MODEL_NOT_FOUND", message)
    default:
      return RequestError("NETWORK", message)
  }
}
```

**Why**: Granular errors self-document via TypeScript, show in IDE hover, enable pattern matching, include `retryable` for consumer logic.

#### 2. Update runtime.ts error calls
**File**: `packages/sdk/src/runtime.ts`
**Location**: line 175 (inside submitPromptEffect)

**Before**:
```typescript
return yield* Effect.fail(toSdkError("Empty prompt", "RuntimeError"))
```

**After**:
```typescript
return yield* Effect.fail(ConfigError("CONFIG_INVALID", "Empty prompt"))
```

**Add import at top**:
```typescript
import { toSdkError, ConfigError } from "./errors.js"
```

#### 3. Update exports
**File**: `packages/sdk/src/index.ts`
**Location**: line 1

**Before**:
```typescript
export type { SdkError, SdkErrorTag } from "./errors.js"
```

**After**:
```typescript
export type { SdkError, SdkErrorTag, ConfigErrorCode, ProviderErrorCode, RequestErrorCode, HookErrorCode } from "./errors.js"
export { ConfigError, ProviderError, RequestError, HookError, isSdkError, toSdkError } from "./errors.js"
```

### Edge Cases to Handle
- [ ] Unknown error type: Falls back to RequestError("NETWORK", message)
- [ ] Error with no message: Use String(error) as message
- [ ] Multiple patterns match: First match wins (order matters in classification)

### Success Criteria

**Automated**:
```bash
bun run typecheck
bun test packages/sdk/tests
```

**Manual**:
- [ ] Hover over `runAgentEffect` in IDE shows full error union
- [ ] `error.retryable` is `true` for rate limits
- [ ] `error.code` is "ABORTED" for abort errors

### Rollback
```bash
git restore packages/sdk/src/errors.ts packages/sdk/src/runtime.ts packages/sdk/src/index.ts
```

### Notes
[Implementation notes go here]

---

## Phase 3: Model Parameters & Result Enrichment

### Overview
Add maxTokens, temperature to options. Add stopReason, durationMs to SdkResult.

### Prerequisites
- [ ] None (can parallel with Phase 1-2)

### Change Checklist
- [ ] Add model params to options types
- [ ] Thread params through to agent
- [ ] Add stopReason to SdkResult
- [ ] Add durationMs to SdkResult
- [ ] Update buildSdkResult
- [ ] Add tests

### Changes

#### 1. Add StopReason type and update SdkResult
**File**: `packages/sdk/src/types.ts`
**Location**: lines 11-19 (SdkResult)

**Before**:
```typescript
export interface SdkResult {
  text: string
  messages: AppMessage[]
  toolCalls: ToolCall[]
  usage?: Usage
  provider: string
  model: string
  sessionId: string | null
}
```

**After**:
```typescript
export type StopReason = "complete" | "maxTokens" | "aborted" | "error"

export interface SdkResult {
  text: string
  messages: AppMessage[]
  toolCalls: ToolCall[]
  usage?: Usage
  provider: string
  model: string
  sessionId: string | null
  stopReason: StopReason
  durationMs: number
}
```

#### 2. Add model params to SdkBaseOptions
**File**: `packages/sdk/src/types.ts`
**Location**: lines 37-40 (SdkBaseOptions)

**Before**:
```typescript
export interface SdkBaseOptions extends LoadConfigOptions {
  instrumentation?: (event: InstrumentationEvent) => void
  transportFactory?: TransportFactory
}
```

**After**:
```typescript
export interface SdkBaseOptions extends LoadConfigOptions {
  instrumentation?: (event: InstrumentationEvent) => void
  transportFactory?: TransportFactory
  maxTokens?: number
  temperature?: number
}
```

#### 3. Add to SdkRuntimeOptions
**File**: `packages/sdk/src/runtime.ts`
**Location**: SdkRuntimeOptions interface (lines 18-24)

**Add to interface**:
```typescript
maxTokens?: number
temperature?: number
```

#### 4. Update exports for StopReason
**File**: `packages/sdk/src/index.ts`
**Location**: type exports

**Add**:
```typescript
export type { StopReason } from "./types.js"
```

#### 5. Add setModelParameters to Agent
**File**: `packages/agent/src/agent.ts`
**Location**: after setModel method (around line 200)

**Add**:
```typescript
setModelParameters(params: { maxTokens?: number; temperature?: number }) {
  if (params.maxTokens !== undefined) {
    this._state.maxTokens = params.maxTokens
  }
  if (params.temperature !== undefined) {
    this._state.temperature = params.temperature
  }
}
```

#### 6. Update AgentState type
**File**: `packages/agent/src/types.ts`
**Location**: AgentState interface

**Add fields**:
```typescript
maxTokens?: number
temperature?: number
```

#### 7. Thread params in SDK runtime
**File**: `packages/sdk/src/runtime.ts`
**Location**: inside createSdkRuntimeImpl, after services are created (after line 158)

**Add**:
```typescript
// Apply model parameters if provided
if (options.maxTokens !== undefined || options.temperature !== undefined) {
  services.agent.setModelParameters({
    maxTokens: options.maxTokens,
    temperature: options.temperature,
  })
}
```

#### 8. Update sdk-result.ts signature and implementation
**File**: `packages/sdk/src/sdk-result.ts`
**Location**: buildSdkResult function

**Before**:
```typescript
export const buildSdkResult = (services: RuntimeServices): SdkResult => {
  const messages = services.agent.state.messages
  const lastAssistant = findLastAssistantMessage(messages)
  
  return {
    text: lastAssistant?.content ?? "",
    messages: messages.slice(),
    toolCalls: extractToolCalls(messages),
    usage: lastAssistant?.usage,
    provider: services.config.provider,
    model: services.config.modelId,
    sessionId: services.sessionManager.sessionId,
  }
}
```

**After**:
```typescript
import type { StopReason } from "./types.js"

const deriveStopReason = (message: AppMessage | undefined): StopReason => {
  if (!message) return "error"
  const reason = message.stopReason
  if (reason === "aborted") return "aborted"
  if (reason === "maxTokens") return "maxTokens"
  if (reason === "error") return "error"
  return "complete"
}

export const buildSdkResult = (services: RuntimeServices, startTime: number): SdkResult => {
  const messages = services.agent.state.messages
  const lastAssistant = findLastAssistantMessage(messages)
  const durationMs = Date.now() - startTime
  const stopReason = deriveStopReason(lastAssistant)
  
  return {
    text: lastAssistant?.content ?? "",
    messages: messages.slice(),
    toolCalls: extractToolCalls(messages),
    usage: lastAssistant?.usage,
    provider: services.config.provider,
    model: services.config.modelId,
    sessionId: services.sessionManager.sessionId,
    stopReason,
    durationMs,
  }
}
```

#### 9. Update run-agent.ts to pass startTime
**File**: `packages/sdk/src/run-agent.ts`
**Location**: runAgentEffect function

**Before**:
```typescript
return runtime.submitPromptAndWait(options.prompt, promptOptions).pipe(
  Effect.map(() => buildSdkResult(runtime.services)),
  Effect.ensuring(runtime.close),
)
```

**After**:
```typescript
const startTime = Date.now()
return runtime.submitPromptAndWait(options.prompt, promptOptions).pipe(
  Effect.map(() => buildSdkResult(runtime.services, startTime)),
  Effect.ensuring(runtime.close),
)
```

#### 10. Update session.ts chat function
**File**: `packages/sdk/src/session.ts`
**Location**: chat function inside createAgentSessionEffect

**Before**:
```typescript
const chat = (text: string, promptOptions?: { mode?: PromptDeliveryMode; attachments?: Attachment[] }) => {
  const chatOptions: { mode?: PromptDeliveryMode; attachments?: Attachment[] } = {}
  if (promptOptions?.mode !== undefined) chatOptions.mode = promptOptions.mode
  if (promptOptions?.attachments !== undefined) chatOptions.attachments = promptOptions.attachments
  return runtime.submitPromptAndWait(text, chatOptions).pipe(Effect.map(() => buildSdkResult(runtime.services)))
}
```

**After**:
```typescript
const chat = (text: string, promptOptions?: { mode?: PromptDeliveryMode; attachments?: Attachment[] }) => {
  const startTime = Date.now()
  const chatOptions: { mode?: PromptDeliveryMode; attachments?: Attachment[] } = {}
  if (promptOptions?.mode !== undefined) chatOptions.mode = promptOptions.mode
  if (promptOptions?.attachments !== undefined) chatOptions.attachments = promptOptions.attachments
  return runtime.submitPromptAndWait(text, chatOptions).pipe(Effect.map(() => buildSdkResult(runtime.services, startTime)))
}
```

### Edge Cases to Handle
- [ ] No assistant message: stopReason = "error", durationMs still tracked
- [ ] Abort before any response: stopReason = "aborted"
- [ ] maxTokens = 0: Treat as unset (use provider default)
- [ ] temperature out of range: Pass through, let provider validate

### Success Criteria

**Automated**:
```bash
bun run typecheck
bun test packages/sdk/tests
```

**Manual**:
- [ ] `result.stopReason` is "complete" for normal completion
- [ ] `result.durationMs` is reasonable (>0, <timeout)
- [ ] `temperature: 0` produces deterministic output

### Rollback
```bash
git restore packages/sdk/src/types.ts packages/sdk/src/runtime.ts packages/sdk/src/sdk-result.ts packages/sdk/src/run-agent.ts packages/sdk/src/session.ts packages/sdk/src/index.ts packages/agent/src/agent.ts packages/agent/src/types.ts
```

### Notes
[Implementation notes go here]

---

## Phase 4: Session Export/Import

### Overview
Add session.export() to serialize state, and restore option to createAgentSession.

### Prerequisites
- [ ] Phase 1 complete (abort available for clean export)

### Change Checklist
- [ ] Define SessionState type
- [ ] Add export() to SdkSession interface
- [ ] Add restore option to SdkSessionOptions
- [ ] Implement export in session.ts
- [ ] Handle restore in runtime
- [ ] Update SdkSessionPromise type
- [ ] Add tests

### Changes

#### 1. Define SessionState type
**File**: `packages/sdk/src/types.ts`
**Location**: after SdkSessionSnapshot (around line 30)

**Add**:
```typescript
export interface SessionState {
  readonly version: 1
  readonly messages: AppMessage[]
  readonly provider: string
  readonly model: string
  readonly thinking: ThinkingLevel
  readonly systemPrompt?: string
  readonly exportedAt: number
}
```

#### 2. Add export to SdkSession interface
**File**: `packages/sdk/src/types.ts`
**Location**: SdkSession interface

**Before** (after Phase 1):
```typescript
export interface SdkSession<
  Chat = SdkEffect<SdkResult>,
  Snapshot = SdkEffect<SdkSessionSnapshot>,
  Drain = SdkEffect<string | null>,
  Close = Effect.Effect<void>,
  Abort = Effect.Effect<void>
> {
  chat: (text: string, options?: { mode?: PromptDeliveryMode; attachments?: Attachment[]; signal?: AbortSignal }) => Chat
  snapshot: () => Snapshot
  drainQueue: () => Drain
  abort: () => Abort
  close: () => Close
}
```

**After**:
```typescript
export interface SdkSession<
  Chat = SdkEffect<SdkResult>,
  Snapshot = SdkEffect<SdkSessionSnapshot>,
  Drain = SdkEffect<string | null>,
  Close = Effect.Effect<void>,
  Abort = Effect.Effect<void>,
  Export = SdkEffect<SessionState>
> {
  chat: (text: string, options?: { mode?: PromptDeliveryMode; attachments?: Attachment[]; signal?: AbortSignal }) => Chat
  snapshot: () => Snapshot
  drainQueue: () => Drain
  abort: () => Abort
  export: () => Export
  close: () => Close
}
```

#### 3. Update SdkSessionPromise type
**File**: `packages/sdk/src/types.ts`
**Location**: SdkSessionPromise type

**Before** (after Phase 1):
```typescript
export type SdkSessionPromise = SdkSession<
  Promise<SdkResult>,
  Promise<SdkSessionSnapshot>,
  Promise<string | null>,
  Promise<void>,
  void
>
```

**After**:
```typescript
export type SdkSessionPromise = SdkSession<
  Promise<SdkResult>,
  Promise<SdkSessionSnapshot>,
  Promise<string | null>,
  Promise<void>,
  void,
  Promise<SessionState>
>
```

#### 4. Add restore to SdkSessionOptions
**File**: `packages/sdk/src/types.ts`
**Location**: SdkSessionOptions

**Before**:
```typescript
export interface SdkSessionOptions extends SdkBaseOptions {}
```

**After**:
```typescript
export interface SdkSessionOptions extends SdkBaseOptions {
  restore?: SessionState
}
```

#### 5. Add restore to SdkRuntimeOptions
**File**: `packages/sdk/src/runtime.ts`
**Location**: SdkRuntimeOptions interface

**Add**:
```typescript
restore?: import("./types.js").SessionState
```

#### 6. Implement export in session.ts
**File**: `packages/sdk/src/session.ts`
**Location**: inside createAgentSessionEffect, after abort method

**Add**:
```typescript
const exportSession = () =>
  Effect.sync((): SessionState => ({
    version: 1,
    messages: runtime.services.agent.state.messages.slice(),
    provider: runtime.services.config.provider,
    model: runtime.services.config.modelId,
    thinking: runtime.services.config.thinking,
    systemPrompt: runtime.services.config.systemPrompt,
    exportedAt: Date.now(),
  }))
```

**Update return**:
```typescript
return { chat, snapshot, drainQueue, abort, export: exportSession, close } satisfies SdkSessionEffect
```

**Add import**:
```typescript
import type { SessionState } from "./types.js"
```

#### 7. Handle restore in runtime
**File**: `packages/sdk/src/runtime.ts`
**Location**: inside createSdkRuntimeImpl, after model parameters handling

**Add**:
```typescript
// Restore session if provided
if (options.restore) {
  const state = options.restore
  if (state.version !== 1) {
    return yield* Effect.fail(ConfigError("CONFIG_INVALID", `Unsupported session state version: ${state.version}`))
  }
  services.agent.replaceMessages(state.messages)
}
```

#### 8. Update Promise wrapper in session.ts
**File**: `packages/sdk/src/session.ts`
**Location**: createAgentSession return object

**Add to return object**:
```typescript
export: () => Effect.runPromise(session.export()),
```

#### 9. Update exports
**File**: `packages/sdk/src/index.ts`
**Location**: type exports

**Add**:
```typescript
export type { SessionState } from "./types.js"
```

### Edge Cases to Handle
- [ ] Export with pending request: Document that caller should abort first
- [ ] Restore with incompatible version: Fail with ConfigError
- [ ] Restore with empty messages: Valid, starts fresh conversation
- [ ] Restore with different provider/model: Use restored values as reference only, actual config from options

### Success Criteria

**Automated**:
```bash
bun run typecheck
bun test packages/sdk/tests
```

**Manual**:
- [ ] `const state = await session.export()` returns valid JSON
- [ ] `JSON.stringify(state)` works (serializable)
- [ ] `createAgentSession({ restore: state })` resumes conversation
- [ ] Messages are preserved across export/import

### Rollback
```bash
git restore packages/sdk/src/types.ts packages/sdk/src/session.ts packages/sdk/src/runtime.ts packages/sdk/src/index.ts
```

### Notes
[Implementation notes go here]

---

## Testing Strategy

### Unit Tests to Add/Modify

**File**: `packages/sdk/tests/abort.test.ts` (new)

```typescript
import { describe, it, expect } from "bun:test"
import { runAgent, createAgentSession } from "../src/index.js"

describe("abort", () => {
  it("should abort with AbortSignal.timeout", async () => {
    const result = await runAgent({
      prompt: "Count from 1 to 1000 very slowly",
      signal: AbortSignal.timeout(50),
    })
    
    expect(result.ok).toBe(false)
    if (!result.ok) {
      expect(result.error._tag).toBe("RequestError")
      expect(result.error.code).toBe("ABORTED")
    }
  })

  it("should abort with manual AbortController", async () => {
    const controller = new AbortController()
    const promise = runAgent({
      prompt: "Count from 1 to 1000",
      signal: controller.signal,
    })
    
    setTimeout(() => controller.abort(), 10)
    
    const result = await promise
    expect(result.ok).toBe(false)
  })

  it("should fail immediately if signal already aborted", async () => {
    const controller = new AbortController()
    controller.abort()
    
    const result = await runAgent({
      prompt: "Hello",
      signal: controller.signal,
    })
    
    expect(result.ok).toBe(false)
    if (!result.ok) {
      expect(result.error.code).toBe("ABORTED")
    }
  })
})
```

**File**: `packages/sdk/tests/errors.test.ts` (new)

```typescript
import { describe, it, expect } from "bun:test"
import { toSdkError, ProviderError, RequestError, ConfigError } from "../src/errors.js"

describe("error classification", () => {
  it("classifies rate limit errors", () => {
    const error = toSdkError(new Error("rate limit exceeded"))
    expect(error._tag).toBe("ProviderError")
    expect(error.code).toBe("RATE_LIMITED")
    expect(error.retryable).toBe(true)
  })

  it("classifies auth errors", () => {
    const error = toSdkError(new Error("invalid api key"))
    expect(error._tag).toBe("ProviderError")
    expect(error.code).toBe("AUTH")
    expect(error.retryable).toBe(false)
  })

  it("classifies abort errors", () => {
    const abortError = new DOMException("Aborted", "AbortError")
    const error = toSdkError(abortError)
    expect(error._tag).toBe("RequestError")
    expect(error.code).toBe("ABORTED")
  })

  it("classifies network errors", () => {
    const error = toSdkError(new Error("ECONNREFUSED"))
    expect(error._tag).toBe("RequestError")
    expect(error.code).toBe("NETWORK")
    expect(error.retryable).toBe(true)
  })

  it("classifies timeout errors", () => {
    const error = toSdkError(new Error("request timed out"))
    expect(error._tag).toBe("RequestError")
    expect(error.code).toBe("TIMEOUT")
  })
})

describe("error constructors", () => {
  it("ConfigError is not retryable", () => {
    const error = ConfigError("CONFIG_MISSING", "No config found")
    expect(error.retryable).toBe(false)
  })

  it("ProviderError RATE_LIMITED is retryable", () => {
    const error = ProviderError("RATE_LIMITED", "Too many requests")
    expect(error.retryable).toBe(true)
  })

  it("ProviderError AUTH is not retryable", () => {
    const error = ProviderError("AUTH", "Bad key")
    expect(error.retryable).toBe(false)
  })
})
```

**File**: `packages/sdk/tests/session-export.test.ts` (new)

```typescript
import { describe, it, expect } from "bun:test"
import { createAgentSession } from "../src/index.js"

describe("session export/import", () => {
  it("should export session state", async () => {
    const session = await createAgentSession({})
    await session.chat("Remember the number 42")
    
    const state = await session.export()
    
    expect(state.version).toBe(1)
    expect(state.messages.length).toBeGreaterThan(0)
    expect(typeof state.exportedAt).toBe("number")
    expect(state.provider).toBeDefined()
    expect(state.model).toBeDefined()
    
    await session.close()
  })

  it("should restore session from state", async () => {
    const session1 = await createAgentSession({})
    await session1.chat("My secret code is ABC123")
    const state = await session1.export()
    await session1.close()
    
    const session2 = await createAgentSession({ restore: state })
    const snapshot = await session2.snapshot()
    
    expect(snapshot.messages.length).toBe(state.messages.length)
    
    await session2.close()
  })

  it("should fail on invalid version", async () => {
    const invalidState = {
      version: 99 as const,
      messages: [],
      provider: "anthropic",
      model: "test",
      thinking: "off" as const,
      exportedAt: Date.now(),
    }
    
    await expect(createAgentSession({ restore: invalidState as any })).rejects.toThrow()
  })
})
```

### Integration Tests
- [ ] Full round-trip: prompt → abort → verify partial state
- [ ] Export → import → continue conversation → verify context

### Manual Testing Checklist
1. [ ] Run abort test with real provider, verify clean termination
2. [ ] Export session, close app, restore, verify conversation continues
3. [ ] Test with invalid API key, verify AUTH error with retryable=false
4. [ ] Verify error types show correctly in IDE autocomplete

## Anti-Patterns to Avoid
- Don't swallow abort errors - always propagate to consumer
- Don't hold references after close() - causes memory leaks
- Don't mutate SessionState after export - treat as immutable
- Don't block on abort() - should be synchronous

## Open Questions
- [x] Should abort() return Promise or void? → void (synchronous)
- [x] Should export() wait for pending requests? → no, caller should abort first
- [x] Version field type: literal `1` or `number`? → literal `1` for type safety

## References
- Existing abort: `packages/agent/src/agent.ts:196-198`
- Error classification: `packages/runtime-effect/src/session/execution-plan.ts:43-74`
- AppMessage stopReason: `packages/agent/src/types.ts`
